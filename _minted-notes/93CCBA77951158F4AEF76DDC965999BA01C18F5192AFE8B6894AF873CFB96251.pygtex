\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZpc{} spawn\PYGZus{}link: This one behaves exactly as you\PYGZsq{}d expect. It spawns a}
\PYG{c}{\PYGZpc{} process, links you with it, and then returns the spawned pid.}
\PYG{n+nb}{spawn\PYGZus{}link}\PYG{p}{(}\PYG{n+nv}{Fun}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}}
    \PYG{n+nv}{Pid}\PYG{p}{.}
\PYG{n+nb}{spawn\PYGZus{}link}\PYG{p}{(}\PYG{n+nv}{M}\PYG{p}{,} \PYG{n+nv}{F}\PYG{p}{,} \PYG{n+nv}{A}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{c}{\PYGZpc{} Module Fun Args}
    \PYG{n+nv}{Pid}\PYG{p}{.}

\PYG{c}{\PYGZpc{} spawn\PYGZus{}monitor: Same as spawn\PYGZus{}link, but with a monitor from your}
\PYG{c}{\PYGZpc{} process into the spawned process. You then get returned a Pid and}
\PYG{c}{\PYGZpc{} Ref, which is a reference to the process (think of it like a handle}
\PYG{c}{\PYGZpc{} [or an interned pointer]).}
\PYG{n+nb}{spawn\PYGZus{}monitor}\PYG{p}{(}\PYG{n+nv}{Fun}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}}
    \PYG{p}{\PYGZob{}}\PYG{n+nv}{Pid}\PYG{p}{,} \PYG{n+nv}{Ref}\PYG{p}{\PYGZcb{}.}
\PYG{n+nb}{spawn\PYGZus{}monitor}\PYG{p}{(}\PYG{n+nv}{M}\PYG{p}{,} \PYG{n+nv}{F}\PYG{p}{,} \PYG{n+nv}{A}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{c}{\PYGZpc{} Module Fun Args}
    \PYG{p}{\PYGZob{}}\PYG{n+nv}{Pid}\PYG{p}{,} \PYG{n+nv}{Ref}\PYG{p}{\PYGZcb{}.}
\PYG{c}{\PYGZpc{} If this process dies, then the message}
\PYG{c}{\PYGZpc{} \PYGZob{}\PYGZsq{}DOWN\PYGZsq{}, Ref, process, Pid, \PYGZpc{} Why\PYGZcb{}}
\PYG{c}{\PYGZpc{} is received.}

\PYG{c}{\PYGZpc{} This turns you to system process}
\PYG{n+nb}{process\PYGZus{}flag}\PYG{p}{(}\PYG{n}{trap\PYGZus{}exit}\PYG{p}{,} \PYG{n}{true}\PYG{p}{).}

\PYG{c}{\PYGZpc{} this does exactly what you think}
\PYG{n+nb}{link}\PYG{p}{(}\PYG{n+nv}{Pid}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{true}\PYG{p}{.}

\PYG{c}{\PYGZpc{} can you guess what this one does?}
\PYG{n+nb}{unlink}\PYG{p}{(}\PYG{n+nv}{Pid}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{true}\PYG{p}{.}

\PYG{c}{\PYGZpc{} monitor: This sets up a monitor to a process. Item is either a Pid}
\PYG{c}{\PYGZpc{} or a registered name}
\PYG{n+nn}{erlang}\PYG{p}{:}\PYG{n+nb}{monitor}\PYG{p}{(}\PYG{n}{process}\PYG{p}{,} \PYG{n+nv}{Item}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}}
     \PYG{n+nv}{Ref}\PYG{p}{.}

\PYG{c}{\PYGZpc{} can you imagine what this does}
\PYG{n+nb}{demonitor}\PYG{p}{(}\PYG{n+nv}{Ref}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{true}\PYG{p}{.}

\PYG{c}{\PYGZpc{} exit/1: this terminates the process and, if not executed within a}
\PYG{c}{\PYGZpc{} catch statement, broadcasts an exit signal and down signal.}
\PYG{n+nb}{exit}\PYG{p}{(}\PYG{n+nv}{Why}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}}
    \PYG{n}{none}\PYG{p}{().}

\PYG{c}{\PYGZpc{} exit/2: this simply sends an exit signal to the specified Pid,}
\PYG{c}{\PYGZpc{} without stopping your own process.}
\PYG{n+nb}{exit}\PYG{p}{(}\PYG{n+nv}{Pid}\PYG{p}{,} \PYG{n+nv}{Why}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{true}\PYG{p}{.}
\end{Verbatim}
